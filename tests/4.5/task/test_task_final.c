//===-- test_task_final.c ------------------------------------------------===//
//
// OpenMP API Version 4.5 Nov 2015
//
// Description:
// testTaskWithFinalSimple():
// This test demonstrates the use of final clause with tasks.
// In this test we prove that omp_in_final() returns true
// when the task is final else returns false.
//
//testNestedTaskWithFinalSimple()
//This test demonstrates that all nested tasks under a final task
// are also final tasks.
//
//testTaskWithFinalAdvanced()
//This test demonstrates the use of final clause with tasks.
// In this test we prove that if a task is declared as final,
// then all subsequent tasks generated by this task will undeferred
// tasks. Hence they all will be executed in the same thread as
// parent task and each child task will be executed in order.

//===----------------------------------------------------------------------===//

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <omp.h>
#include "ompvv.h"

// defines
#define INC 5
#define MUL 7
#define DIV 3
#define DEC 11
#define INITVAL 10

int testTaskWithFinalSimple(int numThreads, int isFinal) {
  int errors = 0;
  int ret = 0;
  int *A = (int*) (malloc(numThreads*sizeof(int)));
  assert(A != NULL);
  omp_set_num_threads(numThreads);
  // Initialize the arrays
  for (int i = 0; i < numThreads; i++) {
    A[i] = -1;
  }
#pragma omp parallel
  {
    int id = omp_get_thread_num();
  // undeferred
#pragma omp task final(isFinal)
    {
      A[id] = omp_in_final();
    }
  }
  for (int i = 0; i < numThreads; i++) {
    if ((isFinal == 1) && (A[i] == 0)) {
      ret = -1;
      break;
    } else if ((isFinal == 0) && (A[i] != 0)) {
      ret = -1;
      break;
    }
  }
  free(A);
  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);
  return errors;
}

int testNestedTaskWithFinalSimple(int numThreads) {
  int errors = 0;
  int ret = 0;
  int *A = (int*) (malloc(numThreads*sizeof(int)));
  assert(A != NULL);
  omp_set_num_threads(numThreads);
  // Initialize the arrays
  for (int i = 0; i < numThreads; i++) {
    A[i] = 0;
  }
#pragma omp parallel
  {
    int id = omp_get_thread_num();
  // undeferred
#pragma omp task final(1)
    {
#pragma omp task shared(id)
      {
        A[id] = omp_in_final();
      }
    }
  }
  for (int i = 0; i < numThreads; i++) {
    if (A[i] == 0) {
      ret = -1;
      break;
    }
  }
  free(A);
  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);
  return errors;
}

int testTaskWithFinalAdvanced(int numThreads) {
  int errors = 0;
  int ret = 0;
  int *A = (int*) (malloc(numThreads*sizeof(int)));
  assert(A != NULL);
  int *B = (int*) (malloc(numThreads*sizeof(int)));
  assert(B != NULL);
  omp_set_num_threads(numThreads);
  // Initialize the arrays
  for (int i = 0; i < numThreads; i++) {
    A[i] = 0;
    B[i] = INITVAL;
  }
#pragma omp parallel
  {
    int id = omp_get_thread_num();
#pragma omp task final(1)
    {
      int first_final_task_thrdid = omp_get_thread_num();
      int first_1stchld_task_thrdid = 0, first_2ndchld_task_thrdid = 0,
      first_3rdchld_task_thrdid = 0, root_id = id;
#pragma omp task shared(first_1stchld_task_thrdid, root_id)
        {
          first_1stchld_task_thrdid = omp_get_thread_num();
          B[root_id] += INC;
#pragma omp task shared(root_id)
          {
            B[root_id] /= DIV;
          }
        }
#pragma omp task shared(first_2ndchld_task_thrdid, root_id)
        {
          first_2ndchld_task_thrdid = omp_get_thread_num();
          B[root_id] *= MUL;
        }
#pragma omp task shared(first_3rdchld_task_thrdid, root_id)
        {
          first_3rdchld_task_thrdid = omp_get_thread_num();
          B[root_id] -= DEC;
        }
        if ((first_final_task_thrdid == first_1stchld_task_thrdid) &&
           (first_final_task_thrdid == first_2ndchld_task_thrdid) &&
           (first_final_task_thrdid == first_3rdchld_task_thrdid)) {
          A[root_id] = 1;
        }
    }
  }
  for (int i = 0; i < numThreads; i++) {
    if ((A[i] != 1) || (B[i] != (((INITVAL + INC)/DIV)*MUL - DEC))) {
      ret = 1;
      break;
    }    
  }
  free(B);
  free(A);
  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);
  return errors;
}

int main() {
  int errors = 0;
  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(4));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(8));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(16));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(32));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(64));

  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 1));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 1));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 1));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 1));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 1));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 0));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 0));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 0));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 0));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 0));

  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(4));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(8));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(16));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(32));
  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(64));
  OMPVV_REPORT_AND_RETURN(errors);
}
